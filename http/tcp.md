## HTTP协议
TCP三次握手、四次挥手及状态转换图：https://www.cnblogs.com/wujing-hubei/p/5699773.html<br>
![avatar](https://github.com/qingjiaowolwh/LearnPicture/blob/main/http.jpg?raw=true)
### 三次握手<br>
第一次握手：客户端发送syn包（syn=x）的数据包到服务器，并进入SYN_SEND状态，等待服务器确认；<br>
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>
第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>
握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将被一直保持下去。
##四次挥手<br>
客户端经过两倍的msl事件之后自动会进入一个close状态

为什么要四次?<br>
三次握手其实是把第二步和第四步做了一个合并
客服端发送FIN仅仅表示客户端不再发送数据，但是服务端还能够接收数据
服务端收到FIN报文后先发一个ACK应答报文
服务端可能还有数据需要处理和发送
只有等到服务端不再发送数据时才发送FIN给客户端，表示统一关闭连接
所以不能和三次握手的时候一样进行合并

为什么需要2msl时间关闭？<br>
MSL(Maximum Segment Lifetime)指报文最大的生存时间
也就是说任何报文在网络上存在的最长时间，经过这个时间的话将会被丢弃
，因此报文经过一来一回刚好是两倍的MSL<br>
如果我们的服务端没有收到客户端最后的ack报文，那超时之后服务端会重发我们的FIN报文
，那当客户端再次接收到这个重传的FIN报文之后会再次发送ACK
，如果此时服务端收到对方的ACK就不会再发送任何消息
，因此客户端为了确保对方能收到ACK报文必须要等待一段时间
，最坏情况下ACK消息的最大存活时间+FIN消息的最大存活时间刚好是2MSL<br>
另一个重要的原因 如果网络中有一个迟到的数据包没有被服务端接收
断开连接后客户端又在相同的端口与服务器进行了一个新的连接
那此时迟到的数据包到达服务端，服务端以为是新的客户端发送过来的消息
在经过2MSL时间之后，足以让两个方向上的数据包都被丢弃，不会接收过期的数据包

